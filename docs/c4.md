# C4 Model – Home Meal Planning System

This document describes the system using the **C4 model**, focusing on the **Context** and **Container** levels, which are appropriate for the scope of this TFM.

---

## Level 1 – System Context

### Purpose

The **Home Meal Planning System** helps households reduce time and cognitive load related to:

- deciding what to cook each day
- managing home food inventory
- generating shopping lists to avoid waste and missing ingredients

The system acts as a decision-support backend rather than a simple recipe or inventory application.

---

### People

**Household User**
- Manages the household inventory
- Requests daily meal suggestions
- Generates shopping lists
- Accesses the system via a future mobile or web client

**Admin (future)**
- Operational support and monitoring
- No admin interface implemented in the current scope

---

### External Systems

**PostgreSQL Database**
- Stores inventory and recipes
- Accessed via Prisma ORM

Future external systems (not implemented):
- Authentication provider
- Supermarket integrations
- Notification services

---

### System Context Diagram

```
+---------------------------+
|     Household User        |
|  (Web / Mobile Client)    |
+-------------+-------------+
              |
              | HTTP (JSON)
              v
+---------------------------------------------+
|        Home Meal Planning System             |
|                                             |
|  - Inventory management                     |
|  - Meal suggestion generation               |
|  - Shopping list generation                 |
+-------------+-------------------------------+
              |
              | SQL (via Prisma ORM)
              v
+---------------------------+
|        PostgreSQL         |
|  (Inventory + Recipes)   |
+---------------------------+
```

---

### Context Notes

- Client applications are not implemented yet; the system is currently accessed through an HTTP API.
- The system is designed as a backend-first architecture with a clean separation of concerns.

---

## Level 2 – Container Diagram

### Containers Overview

The system is composed of the following main containers:

---

### 1. HTTP API (Fastify)

**Responsibilities**
- Expose REST endpoints (JSON over HTTP)
- Validate input/output using Zod schemas
- Map requests to application use cases

**Implemented Endpoints**
- `POST /inventory/update`
- `POST /suggestions/generate`
- `POST /shopping-list/generate`
- `POST /shopping-list/from-recipes`

---

### 2. Application Core (Domain + Use Cases)

**Responsibilities**
- Encapsulate all business rules
- Orchestrate domain logic via use cases
- Remain independent of frameworks and infrastructure

**Implemented Use Cases**
- UpdateInventoryUseCase
- GenerateDailySuggestionUseCase
- GenerateShoppingListUseCase
- GenerateShoppingListFromRecipesUseCase

All use cases are unit-tested using Vitest.

---

### 3. Infrastructure Layer

**Responsibilities**
- Implement repository interfaces
- Handle persistence and database access

**Technology**
- Prisma ORM
- PostgreSQL

**Repositories**
- PrismaInventoryRepository
- PrismaRecipeRepository

---

### 4. Contracts Package

**packages/contracts**

**Responsibilities**
- Define request/response schemas
- Provide runtime validation (Zod)
- Share TypeScript types between backend and clients

Acts as a single source of truth for API contracts.

---

### Container Diagram

```
+---------------------------+
|     Household User        |
|  (Future Web / Mobile)    |
+-------------+-------------+
              |
              | HTTP (JSON)
              v
+---------------------------------------------+
|           HTTP API (Fastify)                 |
|                                             |
|  - Routes / Controllers                     |
|  - Zod validation                           |
|  - Mappers (Contracts ↔ Use Cases)          |
+-------------+-------------------------------+
              |
              | invokes
              v
+---------------------------------------------+
|        Application Core                     |
|  (Clean Architecture)                       |
|                                             |
|  - Use Cases                                |
|  - Domain Entities                          |
|  - Value Objects                            |
|  - Repository Ports                         |
+-------------+-------------------------------+
              |
              | implemented by
              v
+---------------------------------------------+
|        Infrastructure Layer                 |
|                                             |
|  - PrismaInventoryRepository                |
|  - PrismaRecipeRepository                   |
+-------------+-------------------------------+
              |
              | SQL
              v
+---------------------------+
|        PostgreSQL         |
+---------------------------+


+---------------------------------------------+
|        Contracts Package                    |
|  packages/contracts                        |
|  (Zod schemas + TS types)                  |
|  Used by API and clients                   |
+---------------------------------------------+
```

---

### Key Architectural Decisions

- **Clean Architecture** ensures that business logic is isolated from frameworks and infrastructure.
- **Prisma ORM** provides safe persistence and schema migrations.
- **Zod contracts** enforce runtime validation and shared API definitions.
- The database schema is not a 1:1 mirror of the domain model, by design.

---

## Scope Note (TFM)

This document intentionally covers only:
- **C4 Level 1 – Context**
- **C4 Level 2 – Container**

Lower-level diagrams (Component / Code) are optional and can be added if required.

---

## Summary

The current architecture provides:
- A clear separation of responsibilities
- A testable and extensible core
- A solid backend foundation suitable for future frontend integration

The system is production-oriented while remaining appropriate in scope for a TFM.

# C4 Model – Level 3 (Component)

This section provides a **Component-level** view for the main containers of the system, focused on what is relevant for the TFM scope.

---

## Level 3 – Component Diagram (HTTP API / Fastify)

### Responsibilities (recap)
- Accept HTTP requests
- Validate input/output using shared Zod contracts
- Map contracts ↔ application DTOs
- Invoke application use cases
- Return HTTP responses

### Main components

#### 1) Routes / Controllers (Fastify handlers)
- Define endpoints and bind them to handlers:
  - `POST /inventory/update`
  - `POST /suggestions/generate`
  - `POST /shopping-list/generate`
  - `POST /shopping-list/from-recipes`

#### 2) Validation Boundary (Contracts)
- Uses `packages/contracts`:
  - Request validation with Zod schemas (runtime)
  - Response validation with Zod schemas (runtime)

This boundary ensures that invalid payloads never reach the application core.

#### 3) Mappers
- Transform:
  - Contract DTO → Use case input DTO
  - Use case output DTO → Contract response DTO

Example mappers:
- `update-inventory.mapper.ts`
- `daily-suggestion.mapper.ts`
- `shopping-list.mapper.ts`
- `shopping-list-from-recipes.mapper.ts`

#### 4) Composition Root (Manual DI)
- `server.ts` creates and wires dependencies:
  - repositories (Prisma)
  - use cases
  - route handlers

---

### Component diagram (ASCII)

HTTP API (Fastify)
-----------------

```
+-------------------------------+
| Routes / Controllers          |
| (Fastify handlers)            |
+---------------+---------------+
                |
                | validate (Zod)
                v
+-------------------------------+
| Contracts (Zod Schemas)       |
| Request / Response validation |
+---------------+---------------+
                |
                | map DTOs
                v
+-------------------------------+
| Mappers                       |
| (Contract ↔ Use Case DTOs)    |
+---------------+---------------+
                |
                | invoke
                v
+-------------------------------+
| Application Use Cases         |
| execute(input)                |
+-------------------------------+


+-------------------------------+
| Composition Root              |
| (server.ts)                   |
| Manual dependency wiring      |
+-------------------------------+
```

---

## Level 3 – Component Diagram (Application Core)

### Responsibilities (recap)
- Implement business use cases
- Orchestrate domain entities and value objects
- Depend only on the domain and on ports (interfaces)

### Main components

#### 1) Use Cases
- `UpdateInventoryUseCase`
- `GenerateDailySuggestionUseCase`
- `GenerateShoppingListUseCase`
- `GenerateShoppingListFromRecipesUseCase`

Each use case:
- receives an input DTO
- executes business rules using domain entities
- calls ports (repositories) for persistence access
- returns an output DTO

#### 2) Domain Model
- Entities:
  - `Inventory` (aggregate root)
  - `InventoryItem`
  - `Recipe`
- Value Objects:
  - `Quantity`

#### 3) Ports (Repository Interfaces)
- `InventoryRepository`
- `RecipeRepository`

Use cases depend on ports, never on concrete implementations.

---

### Component diagram (ASCII)

Application Core
----------------

```
+-------------------------------+
| Use Cases                     |
|                               |
| - UpdateInventoryUseCase      |
| - GenerateDailySuggestionUC   |
| - GenerateShoppingListUC      |
| - GenerateShoppingListFromRC  |
+---------------+---------------+
                |
                | uses
                v
+-------------------------------+
| Domain Model                  |
|                               |
| - Inventory (Aggregate Root)  |
| - InventoryItem               |
| - Recipe                      |
| - Quantity (Value Object)     |
+---------------+---------------+
                |
                | depends on
                v
+-------------------------------+
| Ports (Interfaces)            |
|                               |
| - InventoryRepository         |
| - RecipeRepository            |
+-------------------------------+
```

---

## Level 3 – Component Diagram (Infrastructure)

### Responsibilities (recap)
- Implement ports
- Translate DB rows ↔ domain objects
- Handle persistence details and migrations

### Main components

#### 1) Prisma Client
- `prisma-client.ts` exports a PrismaClient instance
- Used by repository implementations

#### 2) Repository Implementations
- `PrismaInventoryRepository`
- `PrismaRecipeRepository`

#### 3) Database Schema (Prisma models)
- `Household`
- `InventoryItem`
- `Recipe`
- `RecipeIngredient`

---

### Component diagram (ASCII)

Infrastructure Layer
--------------------

```
+-------------------------------+
| PrismaInventoryRepository     |
| PrismaRecipeRepository        |
+---------------+---------------+
                |
                | uses
                v
+-------------------------------+
| Prisma Client                 |
| (PrismaClient instance)       |
+---------------+---------------+
                |
                | SQL
                v
+-------------------------------+
| PostgreSQL                    |
|                               |
| - Household                   |
| - InventoryItem               |
| - Recipe                      |
| - RecipeIngredient            |
+-------------------------------+
```

---

## End-to-end request flow (example)

```
HTTP Request
     |
     v
Controller
     |
     v
Zod Validation
     |
     v
Mapper
     |
     v
Use Case
     |
     v
Domain Logic
     |
     v
Repository (Prisma)
     |
     v
PostgreSQL
```

Example: `POST /shopping-list/from-recipes`

1. Controller receives request
2. Request validated with `zGenerateShoppingListFromRecipesRequest`
3. Mapper converts contract → input DTO
4. `GenerateShoppingListFromRecipesUseCase.execute(...)`
5. Use case loads inventory via `InventoryRepository`
6. Use case loads recipes via `RecipeRepository.getByIds(...)`
7. Domain logic calculates missing ingredients
8. Mapper converts output DTO → contract response
9. Response validated with `zGenerateShoppingListFromRecipesResponse`
10. HTTP response returned

---

## Scope Note (TFM)

This Level 3 view focuses on the backend and is sufficient for:
- explaining responsibilities and boundaries
- showing Clean Architecture in practice
- defending design decisions during evaluation